<html>

<head>
  <meta charset="utf-8" />
  <style type="text/css">
    /* body {
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }

    body>* {
      position: fixed;
    } */

    .ClickArea {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;

      border: 0.1em dashed;
      border-radius: 3px;
      padding: 0.5em;

      user-select: none;
    }

    #CanvasStack {
      position: absolute;
      left: 0;
      top: 0;
      display: flex;
    }

    #CanvasStack>:not(:nth-child(1)) {
      position: absolute;
    }

    div.ModalDialogContainer {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background-color: rgba(117, 117, 117, 0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    div.ModalDialogContainer>* {
      margin-top: 1em;
    }

    li>span {
      font-size: smaller;
    }
  </style>
</head>

<body>
  <div id="StartPage">
    <div id="OpenImageArea" class="ClickArea" accept-file="image/*" style="padding: 2em;">
      <div style="font-weight: bold;">打开图片</div>
      <div style="font-size: x-small;">点击此处或将图片拖至此处</div>
    </div>
    <h3>介绍</h3>
    <p>一个简单快速的图片批注器。</p>
    <h3>使用说明</h3>
    <ol>
      <li>打开要批注的图片；</li>
      <li>使用鼠标，按住左键画箭头，按住右键添加批注；
        <br><span>文字批注：边框会自动向起始点收缩/向终点扩张</span>
        <br><span>图片批注：保持图片比例缩放至边框大小</span>
      </li>
      <li>按回车键保存批注后的图片；</li>
    </ol>
  </div>
  <div id="CanvasStack" style="display: none;">
    <canvas>no canvas!!!</canvas>
  </div>
  <div id="InputDialog" class="ModalDialogContainer" style="display: none;">
    <textarea id="InputTextArea" cols="30" rows="10"></textarea>
    <button class="ClickArea">确认</button>
  </div>

  <script type="text/javascript">
    'use strict'
    // 为所有的定义了可接受文件类型的元素添加处理事件
    // 当用户添加文件后会引发自定义事件 addfile
    document.querySelectorAll('[accept-file]')
      .forEach((element) => {
        const inputAccept = element.getAttribute('accept-file')
        if (inputAccept.indexOf(',') >= 0)
          throw '暂不支持此写法'
        const mimeTypeRegex = new RegExp(`^${inputAccept.replace('*', '.*')}$`) // 参考 input 的 accept 属性用法和 mime 类型定义
        element.addEventListener('click', () => {
          const input = document.createElement('input')
          input.setAttribute('type', 'file')
          input.setAttribute('accept', inputAccept)
          input.addEventListener('change', (ev) => {
            if (input.files.length > 0)
              element.dispatchEvent(new CustomEvent('addfile', { detail: input.files }))
          })
          input.click()
        })
        element.addEventListener('dragover', (ev) => ev.preventDefault())
        element.addEventListener('drop', (ev) => {
          ev.preventDefault()
          const files = ev.dataTransfer.files
          for (const file of files) {
            if (!mimeTypeRegex.test(file.type)) {
              alert('文件类型错误')
              return
            }
          }
          if (files.length > 0)
            element.dispatchEvent(new CustomEvent('addfile', { detail: files }))
        })
      })
  </script>
  <script type="text/javascript">
    'use strict'
    const canvasStack = {
      ui: document.querySelector('#CanvasStack'),
      penStyle: {
        color: 'red',
        width: 3,
        cap: 'round', // butt round square
        join: 'miter', // bevel round miter
        font: window.getComputedStyle(document.body).font,
        /**
         * @param {CanvasRenderingContext2D} ctx
         */
        setContext: function (ctx) {
          ctx.strokeStyle = this.color
          ctx.fillStyle = this.color
          ctx.lineWidth = this.width
          ctx.lineCap = this.cap
          ctx.lineJoin = this.join
          ctx.font = this.font
        },
      },
      curIndex: 0,
      /**
       * 获取当前画布
       * @return {HTMLCanvasElement}
       */
      curCanvas: function () {
        return this.ui.querySelector(`:nth-child(${this.curIndex + 1})`)
      },
      addCanvas: function () {
        const canvas = document.createElement('canvas')
        canvas.width = this.ui.clientWidth
        canvas.height = this.ui.clientHeight
        this.curIndex += 1
        this.ui.insertBefore(canvas, this.curCanvas())
        return canvas
      },
      removeCanvas: function () {
        if (this.curIndex > 0) {
          this.curCanvas().remove()
          this.curIndex -= 1
        }
      },
      clearAll: function () {
        const canvas = this.curCanvas()
        const ctx = canvas.getContext('2d')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
      },
      /**
       * 在当前画面中绘制图像
       * @param {ImageBitmap} imageBitmap
       */
      drawBackgroundImage: function (imageBitmap) {
        const canvas = this.curCanvas()
        canvas.width = imageBitmap.width
        canvas.height = imageBitmap.height
        const ctx = canvas.getContext('2d')
        ctx.drawImage(imageBitmap, 0, 0)
      },
      drawArrow: function (from, to) {
        const length = Math.sqrt((from.x - to.x) ** 2 + (from.y - to.y) ** 2)
        const angle = (from.x < to.x ? 0 : Math.PI) +
          (from.x !== to.x ? Math.atan((to.y - from.y) / (to.x - from.x)) : from.y < to.y ? -Math.PI / 2 : Math.PI / 2)
        const tb = Math.tan(45 / 2 * Math.PI / 180) // 箭头角度计算
        const canvas = this.curCanvas()
        const ctx = canvas.getContext('2d')
        this.penStyle.setContext(ctx)
        ctx.save()
        // 先平移再旋转才能到达箭头起点
        ctx.translate(from.x, from.y)
        ctx.rotate(angle)
        // 向 x 轴正方向画箭头
        ctx.beginPath()
        ctx.moveTo(0, 0)
        ctx.lineTo(length, 0)
        ctx.stroke()
        // 画箭头三角形
        ctx.beginPath()
        ctx.moveTo(length, 0)
        ctx.lineTo(length - ctx.lineWidth / tb, -ctx.lineWidth)
        ctx.lineTo(length - ctx.lineWidth / tb, ctx.lineWidth)
        ctx.closePath()
        ctx.fill()
        ctx.stroke()
        ctx.restore()
      },
      drawRect: function (from, to) {
        const { x, y, w, h } = {
          x: Math.min(from.x, to.x),
          y: Math.min(from.y, to.y),
          w: Math.abs(to.x - from.x),
          h: Math.abs(to.y - from.y),
        }
        const ctx = this.curCanvas().getContext('2d')
        this.penStyle.setContext(ctx)
        ctx.strokeRect(x, y, w, h)
      },
      drawTextRect: function (from, to, text) {
        const ctx = this.curCanvas().getContext('2d')
        this.penStyle.setContext(ctx)
        // 便于使用 actualBoundingBoxDescent 计算文字区域高度
        ctx.textBaseline = 'top'
        const lineInfos = Array.from(/^.*$/gm[Symbol.matchAll](text),
          ([s]) => ({ line: s, textMetrics: ctx.measureText(s) }))
        const { w, h } = lineInfos.reduce((pre, lineInfo) => {
          pre.w = Math.max(pre.w, lineInfo.textMetrics.width)
          pre.h += lineInfo.textMetrics.actualBoundingBoxDescent
          return pre
        }, { w: 0, h: 0 })
        const lineX = from.x < to.x ? from.x + ctx.lineWidth :
          from.x - w - ctx.lineWidth
        const lineY = from.y < to.y ? from.y + ctx.lineWidth :
          from.y - h - ctx.lineWidth
        let curLineY = lineY
        for (const { line, textMetrics } of lineInfos) {
          ctx.fillText(line, lineX, curLineY)
          curLineY += textMetrics.actualBoundingBoxDescent
        }
        const rect = {
          x: lineX - ctx.lineWidth,
          y: lineY - ctx.lineWidth,
          w: w + ctx.lineWidth * 2,
          h: h + ctx.lineWidth * 2
        }
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h)
      },
      drawImageRect: function (from, to, imageBitmap) {
      },
    }
    canvasStack.ui.addEventListener('contextmenu', e => e.preventDefault())
    canvasStack.ui.addEventListener('mousedown', (ev) => {
      let moveListener = null
      const from = { x: ev.pageX, y: ev.pageY }
      let to = { x: ev.pageX, y: ev.pageY }
      switch (ev.button) {
        case 0:// left
          moveListener = (ev) => {
            to.x = ev.pageX
            to.y = ev.pageY
            canvasStack.clearAll()
            canvasStack.drawArrow(from, to)
          }
          break
        case 2: // right
          moveListener = (ev) => {
            to.x = ev.pageX
            to.y = ev.pageY
            canvasStack.clearAll()
            canvasStack.drawRect(from, to)
          }
          break
        default: return
      }
      document.addEventListener('mousemove', () => {
        canvasStack.addCanvas()
      }, { once: true })
      document.addEventListener('mousemove', moveListener)
      document.addEventListener('mouseup', () => {
        document.removeEventListener('mousemove', moveListener)
        if (ev.button === 2) {
          canvasStack.clearAll()
          canvasStack.drawTextRect(from, to, "测试\n大小大小")
        }
      }, { once: true })
    })
  </script>
  <script type="text/javascript">
    'use strict'
    // 打开图片
    document.querySelector('#OpenImageArea')
      .addEventListener('addfile', (ev) => {
        const imageFile = ev.detail[0]
        createImageBitmap(imageFile)
          .then((imageBitmap) => {
            canvasStack.drawBackgroundImage(imageBitmap)
            imageBitmap.close()
          })
        document.querySelector('#StartPage').style.display = 'none'
        canvasStack.ui.style.removeProperty('display')
        canvasStack.ui.autofocus = true
      })
  </script>
</body>

</html>
